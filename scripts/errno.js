/**
 * @file scripts/errno.js
 * @description Fork of 'node-errno' but up-to-date with the new libuv.
 * @copyright 2018-present Karim Alibhai. All rights reserved.
 */

const fs = require('fs')
const path = require('path')
const request = require('request')

const uvRoot = 'https://raw.githubusercontent.com/libuv/libuv'
const libuvH = uvRoot + '/v1.x/include/uv.h'
const libuvErrnoH = uvRoot + '/v1.x/include/uv-errno.h'

const aresRoot = 'https://raw.githubusercontent.com/c-ares/c-ares'
const aresH = aresRoot + '/master/ares.h'
const aresStrErrC = aresRoot + '/master/ares_strerror.c'

// captures errno descriptions that look like this:
//   XX(E2BIG, "argument list too long")
const errorDesc = /^\s*XX\((E[A-Z_0-9]+),\s*\"(.*)\"\)/

// captures errno definitions that look like this:
// #define UV__EAI_ADDRFAMILY  (-3000)
const errorNo = /^#\s*define\s*UV__(E[A-Z_0-9]+)\s*\((\-?[0-9]+)\)/

// captures c-ares definitions like this:
// #define ARES_ENODATA            1
const caresErr = /^#define\s*(ARES_E[A-Z_0-9]+)\s*([0-9]+)/

// captures c-ares string descriptions like this:
//  "unknown",
const caresStrErr = /^\s*"(.*)"(,?)\s*$/

function getData(url) {
  return new Promise((resolve, reject) => {
    request(url, (err, res) => {
      if (err) reject(err)
      else if (!res) reject(new Error('Unknown error'))
      else if (res.statusCode > 399) reject(new Error(`Unknown error: ${res.statusCode}`))
      else resolve(res.body)
    })
  })
}

(async () => {
  const errorCodes = {}

  ;(await getData(libuvH))
    .split('\n')
    .map(line => line.match(errorDesc))
    .filter(Boolean)
    .forEach(match => {
      const code = match[1]

      errorCodes[code] = {
        code,
        description: match[2],
      }
    })

  ;(await getData(libuvErrnoH))
    .split('\n')
    .map(line => line.match(errorNo))
    .filter(Boolean)
    .forEach(match => {
      const code = match[1]

      if (!errorCodes[code]) {
        throw new Error(`Unable to find error: ${code}`)
      }

      errorCodes[code].errno = parseInt(match[2], 10)
    })

    const caresErrorList = (await getData(aresStrErrC))
      .split('\n')
      .map(line => line.match(caresStrErr))
      .filter(Boolean)
      .map(match => match[1])

    ;(await getData(aresH))
      .split('\n')
      .map(line => line.match(caresErr))
      .filter(Boolean)
      .forEach(match => {
        const code = match[1]
        const errno = parseInt(match[2], 10)

        const description = (
          errno >= caresErrorList.length ?
          'unknown' :
          caresErrorList[errno]
        )

        errorCodes[code] = {
          code,
          errno,
          description,
        }
      })

  // ENOTFOUND is a mistake that node made a while ago
  // and is still living with
  errorCodes.ENOTFOUND = {
    code: 'ENOTFOUND',
    errno: 'ENOTFOUND',
    description: 'ENOTFOUND',
  }

  // ENOTFOUND is actually the error used for some other failures
  // See: https://github.com/nodejs/node/blob/12b9ec09b0807a0b362986c80d3c4b9a644c611e/lib/internal/errors.js#L543
  errorCodes.EAI_MEMORY =
  errorCodes.EAI_NODATA =
  errorCodes.EAI_NONAME =
    errorCodes.ENOTFOUND

  const defn = []

  for (const code in errorCodes) {
    if (errorCodes[code]) {
      // some errors have this weird behavior in node
      if (errorCodes[code].errno === undefined) {
        errorCodes[code].errno = code
      }

      defn.push([
        '/**',
        ` * ${errorCodes[code].description}`,
        ' */',
        `export const ${code} = ${JSON.stringify(errorCodes[code], null, 2)}`,
      ].join('\n'))
    }
  }

  fs.writeFileSync(
    path.resolve(__dirname, '..', 'src', 'frenzie', 'errno.js'),
    [
      '/**',
      ' * @file src/frenzie/errno.js',
      ' * @description Contains errno definitions parsed from libuv.',
      ' * @license MIT',
      ' * @copyright 2018-present Karim Alibhai.',
      ' */',
      '',
      '// AUTOGENERATED - DO NOT EDIT',
      '// Updated at: ' + (new Date()).toUTCString(),
      '',
      '',
    ].join('\n') + defn.join('\n\n') + '\n'
  )
})().catch(err => {
  console.error(err)
  process.exit(-1)
})
